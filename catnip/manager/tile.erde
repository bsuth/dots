local TILE_GAP = 4

local TILE_PADDING = {
  top = 4,
  right = 4,
  bottom = 4,
  left = 4,
}

local function tile_max(layout, windows) {
  for _, window in ipairs(windows) {
    window.x = layout.x
    window.y = layout.y
    window.width = layout.width
    window.height = layout.height
  }
}

local function tile_split_horizontal(layout, windows, num_windows = #windows) {
  local total_gap = layout.gap * (num_windows - 1)
  local window_width = (layout.width - total_gap) / num_windows

  for i, window in ipairs(windows) {
    window.x = layout.x + (i - 1) * (window_width + layout.gap)
    window.y = layout.y
    window.width = window_width
    window.height = layout.height
  }
}

local function tile_split_vertical(layout, windows, num_windows = #windows) {
  local total_gap = layout.gap * (num_windows - 1)
  local window_height = (layout.height - total_gap) / num_windows

  for i, window in ipairs(windows) {
    window.x = layout.x
    window.y = layout.y + (i - 1) * (window_height + layout.gap)
    window.width = layout.width
    window.height = window_height
  }
}

local function tile_master_left(layout, windows, num_windows = #windows) {
  if num_windows < 2 {
    tile_max(layout, windows)
    return
  }

  local column_width = (layout.width - layout.gap) / 2

  tile_max({
    gap = layout.gap,
    x = layout.x,
    y = layout.y,
    width = column_width,
    height = layout.height,
  }, { windows[1] })

  local slaves = {}
  for i = 2, num_windows {
    table.insert(slaves, windows[i])
  }

  tile_split_vertical({
    gap = layout.gap,
    x = layout.x + layout.width - column_width,
    y = layout.y,
    width = column_width,
    height = layout.height,
  }, slaves, num_windows - 1)
}

local function tile_grid_horizontal(layout, windows, num_windows = #windows) {
  local num_rows = math.floor(math.sqrt(num_windows))
  local min_cols = math.floor(num_windows / num_rows)
  local num_padded_rows = num_windows % num_rows

  local total_row_gap = layout.gap * (num_rows - 1)
  local window_height = (layout.height - total_row_gap) / num_rows

  local window_index = 1

  for row = 1, num_rows {
    local num_cols = row <= num_padded_rows && min_cols + 1 || min_cols
    local row_windows = {}

    for col = 1, num_cols {
      table.insert(row_windows, windows[window_index])
      window_index += 1
    }

    tile_split_horizontal({
      gap = layout.gap,
      x = layout.x,
      y = layout.y + (row - 1) * (window_height + layout.gap),
      width = layout.width,
      height = window_height,
    }, row_windows, num_cols)
  }
}

local function tile_grid_vertical(layout, windows, num_windows = #windows) {
  local num_cols = math.floor(math.sqrt(num_windows))
  local min_rows = math.floor(num_windows / num_cols)
  local num_padded_cols = num_windows % num_cols

  local total_column_gap = layout.gap * (num_cols - 1)
  local window_width = (layout.width - total_column_gap) / num_cols

  local window_index = 1

  for col = 1, num_cols {
    local num_rows = col <= num_padded_cols && min_rows + 1 || min_rows
    local col_windows = {}

    for row = 1, num_rows {
      table.insert(col_windows, windows[window_index])
      window_index += 1
    }

    tile_split_vertical({
      gap = layout.gap,
      x = layout.x + (col - 1) * (window_width + layout.gap),
      y = layout.y,
      width = window_width,
      height = layout.height,
    }, col_windows, num_rows)
  }
}

return (box, windows, num_windows = #windows) -> {
  local layout = {
    gap = TILE_GAP,
    x = box.x + TILE_PADDING.left,
    y = box.y + TILE_PADDING.top,
    width = box.width - (TILE_PADDING.right + TILE_PADDING.left),
    height = box.height - (TILE_PADDING.top + TILE_PADDING.bottom ),
  }

  if layout.width < layout.height {
    if num_windows < 3 {
      tile_split_vertical(layout, windows, num_windows)
    } else {
      tile_grid_vertical(layout, windows, num_windows)
    }
  } elseif num_windows < 4 {
    tile_master_left(layout, windows, num_windows)
  } else {
    tile_grid_horizontal(layout, windows, num_windows)
  }
}
