local awful = require('awful')
local gears = require('gears')
local wibox = require('wibox')
local { global_keys } = require('core.bindings')
local { palette } = require('core.theme')
local Menu = require('components.Menu')
local Prompt = require('components.Prompt')
local Veil = require('components.Veil')
local Class = require('utils.Class')
local { trim } = require('utils.string')

local TAGBAR_HEIGHT = 48
local TAGBAR_FONT = 'Quicksand Regular 14'

-- -----------------------------------------------------------------------------
-- RECENTLY_USED_TAG_NAMES
-- -----------------------------------------------------------------------------

local TAGBAR_NAME_HISTORY_FILENAME = "{os.getenv('HOME')}/.cache/awesome/tagbar_name_history"
local TAGBAR_NAME_HISTORY_SIZE = 50
local RECENTLY_USED_TAG_NAMES = {}

do {
  local tagbar_name_history_file = io.open(TAGBAR_NAME_HISTORY_FILENAME, 'r+')
  if tagbar_name_history_file {
    for recently_used_tab_name in tagbar_name_history_file:lines() {
      table.insert(RECENTLY_USED_TAG_NAMES, recently_used_tab_name)
    }
    tagbar_name_history_file:close()
  }
}

function write_recently_used_tab_names() {
  local tagbar_name_history_file = io.open(TAGBAR_NAME_HISTORY_FILENAME, 'w')
  tagbar_name_history_file:write(table.concat(RECENTLY_USED_TAG_NAMES, '\n'))
  tagbar_name_history_file:close()
}

function remove_recently_used_tab_name(tab_name) {
  for i, recently_used_tab_name in ipairs(RECENTLY_USED_TAG_NAMES) {
    if recently_used_tab_name == tab_name {
      table.remove(RECENTLY_USED_TAG_NAMES, i)
      break
    }
  }
}

function save_recently_used_tab_name(tab_name) {
  remove_recently_used_tab_name(tab_name)

  table.insert(RECENTLY_USED_TAG_NAMES, 1, tab_name)
  for i = #RECENTLY_USED_TAG_NAMES, TAGBAR_NAME_HISTORY_SIZE + 1, -1 {
    -- Constrain number of saved recently used tab names
    table.remove(RECENTLY_USED_TAG_NAMES, i)
  }

  write_recently_used_tab_names()
}

function delete_recently_used_tab_name(tab_name) {
  remove_recently_used_tab_name(tab_name)
  write_recently_used_tab_names()
}

-- -----------------------------------------------------------------------------
-- TabSuggestions
-- -----------------------------------------------------------------------------

local MAX_TAB_SUGGESTIONS = 10

local TabSuggestions = Class()

function TabSuggestions:_init(props) {
  self.screen = props.screen
  self.suggestions = props.suggestions
  self.filtered_suggestions = props.suggestions
  self.default_suggestion = props.default_suggestion
  self:rawset('selected', 0, true)

  self.suggestion_widgets = {}
  for i = 1, MAX_TAB_SUGGESTIONS {
    table.insert(self.suggestion_widgets, wibox.widget({
      text = '',
      halign = 'center',
      valign = 'center',
      font = TAGBAR_FONT,
      widget = wibox.widget.textbox,
    }))
  }

  self.root_widget = wibox.widget({
    spacing = 16,
    layout  = wibox.layout.fixed.horizontal,
  })

  self.popup = awful.popup({
    widget = {
      {
        self.root_widget,
        widget = wibox.container.place,
      },
      left = 16,
      right = 16,
      widget = wibox.container.margin,
    },
    screen = self.screen,
    visible = false,
    ontop = true,
    x = self.screen.geometry.x,
    y = self.screen.geometry.y + TAGBAR_HEIGHT,
    minimum_width = self.screen.geometry.width,
    minimum_height = TAGBAR_HEIGHT,
    fg = palette.white,
    bg = palette.dark_gray,
  })
}

function TabSuggestions:_on_change_filter() {
  local trimmed_filter = trim(self.filter)
  local new_filtered_suggestions = {}

  for i, suggestion in ipairs(self.suggestions) {
    if suggestion:match(trimmed_filter) {
      table.insert(new_filtered_suggestions, suggestion)
      if #new_filtered_suggestions == MAX_TAB_SUGGESTIONS {
        break
      }
    }
  }

  local new_root_children = {}
  for i = 1, #new_filtered_suggestions {
    local widget = self.suggestion_widgets[i]
    widget.text = new_filtered_suggestions[i]
    table.insert(new_root_children, widget)
  }

  self.filtered_suggestions = new_filtered_suggestions
  self.root_widget.children = new_root_children
  self:rawset('selected', 0, true)
}

function TabSuggestions:_on_change_selected() {
  for i = 1, #self.root_widget.children {
    local widget = self.root_widget.children[i]
    local suggestion = self.filtered_suggestions[i]

    if i == self.selected {
      widget.markup = [[<span foreground="{palette.blue}">{suggestion}</span>]]
    } else {
      widget.text = suggestion
    }
  }
}

function TabSuggestions:show() {
  self.filter = ''
  self.selected = 0
  self.popup.visible = true
}

function TabSuggestions:hide() {
  self.popup.visible = false
}

function TabSuggestions:current() {
  if self.selected == 0 {
    return self.default_suggestion
  } else {
    return self.filtered_suggestions[self.selected]
  }
}

function TabSuggestions:prev() {
  if self.selected == 0 {
    self.selected = #self.filtered_suggestions
  } else {
    self.selected -= 1
  }
  return self:current()
}

function TabSuggestions:next() {
  if self.selected == #self.filtered_suggestions {
    self.selected = 0
  } else {
    self.selected += 1
  }
  return self:current()
}

function TabSuggestions:delete() {
  local current_suggestion = self:current()

  local num_filtered_suggestions = #self.filtered_suggestions
  local new_selected = self.selected < num_filtered_suggestions
    && self.selected || num_filtered_suggestions - 1

  for i, suggestion in ipairs(self.suggestions) {
    if suggestion == current_suggestion {
      table.remove(self.suggestions, i)
      break
    }
  }

  delete_recently_used_tab_name(current_suggestion)
  self:_on_change_filter()
  self.selected = new_selected

  return self:current()
}

-- -----------------------------------------------------------------------------
-- Tab
-- -----------------------------------------------------------------------------

local Tab = Class()

function Tab:_init(props) {
  self.tag = props.tag

  self.name_widget = wibox.widget({
    text = self.tag.name,
    halign = 'center',
    valign = 'center',
    font = TAGBAR_FONT,
    widget = wibox.widget.textbox,
  })

  self.content_widget = wibox.widget({
    self.name_widget,
    widget = wibox.container.place,
  })

  self.root_widget = wibox.widget({
    self.content_widget,
    fg = palette.white,
    bg = self.tag.selected && palette.light_gray || palette.dark_gray,
    widget = wibox.container.background,
  })

  self.tag:connect_signal('property::name', () -> {
    self.name_widget.text = self.tag.name
  })

  self.tag:connect_signal('property::selected', () -> {
    self.root_widget.bg = self.tag.selected && palette.light_gray || palette.dark_gray
  })
}

function Tab:_on_change_disabled() {
  self.root_widget.fg = self.disabled && '#888888' || palette.white
}

function Tab:toggle() {
  self.disabled = !self.disabled
}

-- -----------------------------------------------------------------------------
-- Tagbar
-- -----------------------------------------------------------------------------

local Tagbar = Class()

function Tagbar:_init(props) {
  self.screen = props.screen
  self.tabs = {}
  self.veil = Veil()

  self.tabs_widget = wibox.widget({
    forced_width = self.screen.geometry.width,
    layout  = wibox.layout.flex.horizontal,
  })

  self.wibar = awful.wibar({
    screen = self.screen,
    position = 'top',
    bg = palette.dark_gray,
    height = TAGBAR_HEIGHT,
    type = 'dock', -- remove box shadows
    widget = self.tabs_widget,
  })

  self.tab_suggestions = TabSuggestions({
    screen = self.screen,
    suggestions = RECENTLY_USED_TAG_NAMES,
  })

  self.prompt = Prompt({
    halign = 'center',
    valign = 'center',
    font = TAGBAR_FONT,
    on_user_change = () -> {
      self.tab_suggestions.default_suggestion = self.prompt.text
      self.tab_suggestions.filter = self.prompt.text
    },
    keybindings = {
      { { 'Control' }, 'q', () -> {
        local suggestion = self.tab_suggestions:delete()
        self.prompt:update(suggestion, #suggestion)
      } },
      { {}, 'Tab', () -> {
        local suggestion = self.tab_suggestions:next()
        self.prompt:update(suggestion, #suggestion)
      } },
      { { 'Shift' }, 'Tab', () -> {
        local suggestion = self.tab_suggestions:prev()
        self.prompt:update(suggestion, #suggestion)
      } },
    },
  })

  self:refresh()
  self.screen:connect_signal('tag::history::update', () -> self:refresh())
}

function Tagbar:get_active_tab() {
  for i, tab in ipairs(self.tabs) {
    if tab.tag == self.screen.selected_tag {
      return tab, i
    }
  }
}

function Tagbar:get_prev_tab(tab_index) {
  if !tab_index { local _; _, tab_index = self:get_active_tab() }
  local prev_index = tab_index == 1 && #self.tabs || tab_index - 1
  return self.tabs[prev_index], prev_index
}

function Tagbar:get_next_tab(tab_index) {
  if !tab_index { local _; _, tab_index = self:get_active_tab() }
  local next_index = tab_index == #self.tabs && 1 || tab_index + 1
  return self.tabs[next_index], next_index
}

function Tagbar:open() {
  awful.tag.add(tostring(#self.screen.tags), {
    screen = self.screen,
    layout = awful.layout.layouts[1]
  }):view_only()
}

function Tagbar:close() {
  local num_visible_tags = 0

  for _, tag in ipairs(self.screen.tags) {
    if !tag.name:match('^_') {
      num_visible_tags += 1
    }
  }

  if num_visible_tags > 1 {
    self.screen.selected_tag:delete()
  }
}

function Tagbar:swap(index1, index2) {
  local tmp = self.tabs[index1]
  self.tabs[index1] = self.tabs[index2]
  self.tabs[index2] = tmp
  self.tabs_widget:swap(index1, index2)
  self.tabs[index1].tag:swap(self.tabs[index2].tag)
}

function Tagbar:move_prev() {
  local num_tabs = #self.tabs
  local _, active_tab_index = self:get_active_tab()
  if num_tabs > 1 && active_tab_index > 1 {
    local _, prev_tab_index = self:get_prev_tab()
    self:swap(active_tab_index, prev_tab_index)
  }
}

function Tagbar:move_next() {
  local num_tabs = #self.tabs
  local _, active_tab_index = self:get_active_tab()
  if num_tabs > 1 && active_tab_index < num_tabs {
    local _, next_tab_index = self:get_next_tab()
    self:swap(active_tab_index, next_tab_index)
  }
}

function Tagbar:focus_prev(skip_disabled) {
  if #self.tabs < 2 { return }

  local active_tab, active_tab_index = self:get_active_tab()
  local prev_tab, prev_tab_index = self:get_prev_tab()

  if skip_disabled {
    while prev_tab.disabled {
      if prev_tab == active_tab { break }
      prev_tab, prev_tab_index = self:get_prev_tab(prev_tab_index)
    }
  }

  if prev_tab != active_tab {
    prev_tab.tag:view_only()
  }
}

function Tagbar:focus_next(skip_disabled) {
  if #self.tabs < 2 { return }

  local active_tab, active_tab_index = self:get_active_tab()
  local next_tab, next_tab_index = self:get_next_tab()

  if skip_disabled {
    while next_tab.disabled {
      if next_tab == active_tab { break }
      next_tab, next_tab_index = self:get_next_tab(next_tab_index)
    }
  }

  if next_tab != active_tab {
    next_tab.tag:view_only()
  }
}

function Tagbar:refresh() {
  local new_tabs = {}
  local children = {}

  for _, tag in ipairs(self.screen.tags) {
    if !tag.name:match('^_') {
      local new_tab = nil

      for _, tab in ipairs(self.tabs) {
        if tab.tag == tag {
          new_tab = tab
          break
        }
      }

      new_tab ||= Tab({ tag = tag })
      table.insert(new_tabs, new_tab)
      table.insert(children, new_tab.root_widget)
    }
  }

  self.tabs = new_tabs
  self.tabs_widget.children = children
}

function Tagbar:rename() {
  local rename_tab = self:get_active_tab()
  local focused_screen = awful.screen.focused()
  local focused_veil = self.veil:get_focused_veil()

  self.prompt.on_stop = () -> {
    rename_tab.content_widget.children = { rename_tab.name_widget }
    focused_veil.shape = nil
    self.tab_suggestions:hide()
    self.veil:hide()
  }

  self.prompt.on_submit = () -> {
    if #self.prompt.text > 0 {
      rename_tab.tag.name = self.prompt.text
      save_recently_used_tab_name(self.prompt.text)
    }
  }

  self.tab_suggestions.default_suggestion = rename_tab.tag.name
  rename_tab.content_widget.children = { self.prompt.root_widget }
  focused_veil.shape = (cr, width, height) -> cr:rectangle(0, 2 * TAGBAR_HEIGHT, width, height - (2 * TAGBAR_HEIGHT))

  self.veil:show()
  self.tab_suggestions:show()
  self.prompt:start()
}

-- -----------------------------------------------------------------------------
-- Setup
-- -----------------------------------------------------------------------------

local tagbars = {}

function get_current_tagbar() {
  local focused_screen = awful.screen.focused()
  for _, tagbar in ipairs(tagbars) {
    if tagbar.screen == focused_screen {
      return tagbar
    }
  }
}

gears.table.merge(global_keys, {
  awful.key({ 'Mod4' }, 't', () -> get_current_tagbar():open()),
  awful.key({ 'Mod4' }, 'w', () -> get_current_tagbar():close()),
  awful.key({ 'Mod4', 'Shift' }, ',', () -> get_current_tagbar():move_prev()),
  awful.key({ 'Mod4', 'Shift' }, '.', () -> get_current_tagbar():move_next()),
  awful.key({ 'Mod4' }, 'Tab', () -> get_current_tagbar():focus_next(true)),
  awful.key({ 'Mod4', 'Shift' }, 'Tab', () -> get_current_tagbar():focus_prev(true)),
  awful.key({ 'Mod4', 'Control' }, 'Tab', () -> get_current_tagbar():focus_next()),
  awful.key({ 'Mod4', 'Control', 'Shift' }, 'Tab', () -> get_current_tagbar():focus_prev()),
  awful.key({ 'Mod4', 'Shift' }, 't', () -> get_current_tagbar():rename()),
  awful.key({ 'Mod4', 'Control' }, 't', () -> get_current_tagbar():get_active_tab():toggle()),
})

awful.screen.connect_for_each_screen(s -> table.insert(tagbars, Tagbar({ screen = s })))
awful.screen.disconnect_for_each_screen(s -> {
  for i, tagbar in ipairs(tagbars) {
    if tagbar.screen == s {
      table.remove(tagbars, i)
      break
    }
  }
})
