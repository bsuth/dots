local awful = require('awful')
local gears = require('gears')
local naughty = require('naughty')

-- -----------------------------------------------------------------------------
-- Battery
-- -----------------------------------------------------------------------------

local upower = require('lgi').require('UPowerGlib')
local device = upower.Client():get_display_device()

module battery = gears.table.crush(gears.object(), {
  percent = 0,
  discharging = true,
  sent_low_warning = false,

  update = () => {
    self.percent = device.percentage
    self.discharging = gears.table.hasitem({
      upower.DeviceState.PENDING_DISCHARGE,
      upower.DeviceState.DISCHARGING,
    }, device.state) != nil

    if self.percent < 15 {
      if !self.sent_low_warning {
        naughty.notify({ text = 'Low Battery', force = true })
        self.sent_low_warning = true
      }
    } elseif self.sent_low_warning {
      self.sent_low_warning = false
    }

    self:emit_signal('update')
  },
})

battery:update()
device.on_notify = () -> battery:update()

-- -----------------------------------------------------------------------------
-- Brightness
-- -----------------------------------------------------------------------------

module brightness = gears.table.crush(gears.object(), {
  percent = 0,

  set = percent => {
    self.percent = math.min(math.max(0, percent), 100)
    awful.spawn.easy_async_with_shell(
      ('brightnessctl set %s%%'):format(self.percent),
      () -> self:emit_signal('update'),
    )
  },
})

awful.spawn.easy_async_with_shell(
  [[ echo $(( 100 * $(brightnessctl get) / $(brightnessctl max) )) ]],
  stdout -> {
    brightness.percent = tonumber(stdout)
    brightness:emit_signal('update')
  },
)

-- -----------------------------------------------------------------------------
-- Notifications
-- -----------------------------------------------------------------------------

module notifications = gears.table.crush(gears.object(), {
  -- Use custom active property instead of naughty's suspended state, since
  -- suspended state will save and queue all notifications during suspension,
  -- which we don't want
  active = false,

  toggle = () => {
    self.active = !self.active
    self:emit_signal('update')
  },
})

-- notification.force is a custom property to bypass notifications.active
naughty.config.notify_callback = notification ->
  (notifications.active || notification.force) && notification || nil

-- -----------------------------------------------------------------------------
-- Volume
-- -----------------------------------------------------------------------------

module volume = gears.table.crush(gears.object(), {
  percent = 0,
  active = false,

  set = percent => {
    self.percent = math.min(math.max(0, percent), 100)
    awful.spawn.easy_async_with_shell(
      ('amixer sset Master %d%%'):format(self.percent),
      () -> self:emit_signal('update'),
    )
  },

  toggle = () => awful.spawn.easy_async_with_shell(
    'amixer sset Master toggle',
    () -> {
      self.active = !self.active
      self:emit_signal('update')
    },
  ),
})

awful.spawn.easy_async_with_shell(
  [[ amixer sget Master | tail -n 1 | sed -E 's/.*\[([0-9]+)%\].*/\1/' ]],
  stdout -> {
    volume.percent = tonumber(stdout)
    volume:emit_signal('update')
  },
)

awful.spawn.easy_async_with_shell(
  [[ amixer sget Master | tail -n 1 | sed -E 's/.*\[(off|on)\].*/\1/' ]],
  stdout -> {
    volume.active = string.find(stdout, 'on')
    volume:emit_signal('update')
  },
)
