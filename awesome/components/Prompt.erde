local awful = require('awful')
local wibox = require('wibox')
local { palette } = require('core.theme')
local Class = require('utils.Class')

local WORDCHARS = { _ = true }
for byte = string.byte('0'), string.byte('9') { WORDCHARS[string.char(byte)] = true }
for byte = string.byte('a'), string.byte('z') { WORDCHARS[string.char(byte)] = true }
for byte = string.byte('A'), string.byte('Z') { WORDCHARS[string.char(byte)] = true }

local ENV_WORDCHARS = os.getenv('WORDCHARS')
for i = 1, #ENV_WORDCHARS { WORDCHARS[ENV_WORDCHARS:sub(i, i)] = true }

local Prompt = Class()

-- -----------------------------------------------------------------------------
-- Private
-- -----------------------------------------------------------------------------

function Prompt:_init(props = {}) {
  self:rawset('text', '', true)
  self:rawset('cursor', 0, true)

  self.root_widget = wibox.widget({
    markup = '',
    halign = props.halign,
    valign = props.valign,
    font = props.font,
    widget = wibox.widget.textbox
  })

  local keybindings = {
    { {}, 'Right', () -> self:_move_char_forward() },
    { {}, 'Left', () -> self:_move_char_back() },
    { { 'Control' }, 'f', () -> self:_move_char_forward() },
    { { 'Control' }, 'b', () -> self:_move_char_back() },
    { { 'Mod1' }, 'f', () -> self:_move_word_forward() },
    { { 'Mod1' }, 'b', () -> self:_move_word_back() },
    { { 'Control' }, 'a', () -> self:_move_line_start() },
    { { 'Control' }, 'e', () -> self:_move_line_end() },
    { { 'Control' }, 'd', () -> self:_delete_char_forward() },
    { {}, 'BackSpace', () -> self:_delete_char_back() },
    { { 'Mod1' }, 'd', () -> self:_delete_word_forward() },
    { { 'Mod1' }, 'BackSpace', () -> self:_delete_word_back() },
    { { 'Control' }, 'u', () -> self:_delete_line_start() },
    { { 'Control' }, 'k', () -> self:_delete_line_end() },
    { {}, 'Escape', () -> self:cancel() },
    { { 'Control' }, 'c', () -> self:cancel() },
    { {}, 'Return', () -> self:submit() },
  }

  if props.keybindings {
    for _, keybinding in ipairs(props.keybindings) {
      -- Place custom keybindings at the beginning!
      --
      -- If a keybinding is specified mulitple times, only the first one is used
      -- and we give priority to `props.keybindings`
      table.insert(keybindings, 1, keybinding)
    }
  }

  self._keygrabber = awful.keygrabber({
    keybindings = keybindings,
    keyreleased_callback = (_, mod, key) -> {
      if #mod == 0 && #key == 1 {
        self:rawset('text', table.concat({ self.text:sub(1, self.cursor), key, self.text:sub(self.cursor + 1), }), false)
        self:rawset('cursor', self.cursor + 1, false)
        self:_update_markup()
        self:publish('user_change', self.text)
      }
    },
  })
}

function Prompt:_update_markup() {
  local new_widget_markup = self.text:sub(1, self.cursor)
  new_widget_markup ..= [[<span foreground="{palette.white}">|</span>]]
  new_widget_markup ..= self.text:sub(self.cursor + 1)
  self.root_widget.markup = new_widget_markup
}

function Prompt:_on_change_text() {
  self:_update_markup()
}

function Prompt:_on_change_cursor() {
  self:_update_markup()
}

function Prompt:_move_char_back() {
  self.cursor = math.max(0, self.cursor - 1)
}

function Prompt:_move_char_forward() {
  self.cursor = math.min(#self.text, self.cursor + 1)
}

function Prompt:_move_word_back() {
  if self.cursor > 0 {
    local new_cursor = self.cursor
    local char = self.text:sub(new_cursor, new_cursor)

    while new_cursor > 0 && !WORDCHARS[char] {
      new_cursor -= 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    while new_cursor > 0 && WORDCHARS[char] {
      new_cursor -= 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    self.cursor = new_cursor
  }
}

function Prompt:_move_word_forward() {
  if self.cursor < #self.text {
    local new_cursor = self.cursor
    local next_char = self.text:sub(new_cursor + 1, new_cursor + 1)

    while new_cursor < #self.text && WORDCHARS[next_char] {
      new_cursor += 1
      next_char = self.text:sub(new_cursor + 1, new_cursor + 1)
    }

    while new_cursor < #self.text && !WORDCHARS[next_char] {
      new_cursor += 1
      next_char = self.text:sub(new_cursor + 1, new_cursor + 1)
    }

    self.cursor = new_cursor
  }
}

function Prompt:_move_line_start() {
  self.cursor = 0
}

function Prompt:_move_line_end() {
  self.cursor = #self.text
}

function Prompt:_delete_char_back() {
  if self.cursor > 0 {
    self:rawset('text', self.text:sub(1, self.cursor - 1) .. self.text:sub(self.cursor + 1), false)
    self:rawset('cursor', self.cursor - 1, false)
    self:_update_markup()
    self:publish('user_change', self.text)
  }
}

function Prompt:_delete_char_forward() {
  if self.cursor < #self.text {
    self.text = self.text:sub(1, self.cursor) .. self.text:sub(self.cursor + 2)
    self:publish('user_change', self.text)
  }
}

function Prompt:_delete_word_back() {
  if self.cursor > 0 {
    local new_cursor = self.cursor
    local char = self.text:sub(new_cursor, new_cursor)

    while new_cursor > 0 && !WORDCHARS[char] {
      new_cursor -= 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    while new_cursor > 0 && WORDCHARS[char] {
      new_cursor -= 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    self:rawset('text', self.text:sub(1, new_cursor) .. self.text:sub(self.cursor + 1), false)
    self:rawset('cursor', new_cursor, false)
    self:_update_markup()
    self:publish('user_change', self.text)
  }
}

function Prompt:_delete_word_forward() {
  if self.cursor < #self.text {
    local new_cursor = self.cursor + 1
    local char = self.text:sub(new_cursor, new_cursor)

    while new_cursor < #self.text && !WORDCHARS[char] {
      new_cursor += 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    while new_cursor < #self.text && WORDCHARS[char] {
      new_cursor += 1
      char = self.text:sub(new_cursor, new_cursor)
    }

    self.text = self.text:sub(1, self.cursor) .. self.text:sub(new_cursor)
    self:publish('user_change', self.text)
  }
}

function Prompt:_delete_line_start() {
  if self.cursor > 0 {
    self:rawset('text', self.text:sub(self.cursor + 1), false)
    self:rawset('cursor', 0, false)
    self:_update_markup()
    self:publish('user_change', self.text)
  }
}

function Prompt:_delete_line_end() {
  if self.cursor < #self.text {
    self.text = self.text:sub(1, self.cursor)
    self:publish('user_change', self.text)
  }
}

-- -----------------------------------------------------------------------------
-- Public
-- -----------------------------------------------------------------------------

function Prompt:start(initial_text = '') {
  self:rawset('text', initial_text, false)
  self:rawset('cursor', #initial_text, false)
  self:_update_markup()
  self._keygrabber:start()
}

function Prompt:cancel() {
  self._keygrabber:stop()
  self:publish('stop')
  self:publish('cancel')
}

function Prompt:submit() {
  self._keygrabber:stop()
  self:publish('stop')
  self:publish('submit', self.text)
}

-- -----------------------------------------------------------------------------
-- Return
-- -----------------------------------------------------------------------------

return Prompt
