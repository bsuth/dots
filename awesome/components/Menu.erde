local awful = require('awful')
local gears = require('gears')
local wibox = require('wibox')
local Object = require('core.Object')
local { palette } = require('core.theme')
local { shallowCopy, trim } = require('core.utils')

local MENU_WIDTH = 400
local MENU_PAGE_SIZE = 5

-- -----------------------------------------------------------------------------
-- MenuItem
--
-- props? = {
--   markup = string,
--   active? = boolean,
-- }
-- -----------------------------------------------------------------------------

local MenuItem = {}

function MenuItem:_init(props = {}) {
  self.textWidget = wibox.widget({
    markup = props.markup,
    widget = wibox.widget.textbox,
  })

  self.rootWidget = wibox.widget({
    {
      self.textWidget,
      margins = 16,
      widget = wibox.container.margin,
    },
    fg = palette.white,
    bg = props.active && palette.lightGray || palette.darkGray,
    forced_width = MENU_WIDTH,
    widget = wibox.container.background,
  })
}

function MenuItem:_get_markup() {
  return self.textWidget.markup
}

function MenuItem:_set_markup(newMarkup) {
  self.textWidget.markup = newMarkup
}

function MenuItem:_get_active() {
  return !!gears.color.to_rgba_string(self.rootWidget.bg):find(palette.lightGray)
}

function MenuItem:_set_active(newActive) {
  self.rootWidget.bg = newActive && palette.lightGray || palette.darkGray
}

-- -----------------------------------------------------------------------------
-- Menu
--
-- props = {
--   options<1> = (string | { label = string, options = <1> })[]
--   onSubmit = (option: string) -> void,
--   onClose? = () -> void,
--   allowArbitraryInput? = boolean,
-- }
-- -----------------------------------------------------------------------------

local Menu = {}

function Menu:_init(props) {
  self.options = props.options
  self.onSubmit = props.onSubmit
  self.onClose = props.onClose
  self.allowArbitraryInput = props.allowArbitraryInput

  self.items = {}
  self.itemsWidget = wibox.widget({ layout = wibox.layout.fixed.vertical })
  for i = 1, MENU_PAGE_SIZE {
    local dmenuItem = Object(MenuItem, { markup = '' })
    table.insert(self.items, dmenuItem)
    self.itemsWidget:add(dmenuItem.rootWidget)
  }

  self.promptContainer = wibox.widget({
    margins = 0,
    widget = wibox.container.margin,
  })

  self.rootWidget = wibox.widget({
    {
      {
        {
          {
            {
              markup = 'âžœ ',
              widget = wibox.widget.textbox,
            },
            self.promptContainer,
            layout = wibox.layout.fixed.horizontal,
          },
          margins = 16,
          widget = wibox.container.margin,
        },
        fg = palette.white,
        bg = palette.darkGray,
        forced_width = MENU_WIDTH,
        widget = wibox.container.background,
      },
      shape_border_width = 1,
      shape_border_color = palette.cyan,
      bg = palette.darkGray,
      widget = wibox.container.background,
    },
    {
      self.itemsWidget,
      shape_border_width = 1,
      shape_border_color = palette.cyan,
      bg = palette.darkGray,
      widget = wibox.container.background,
    },
    spacing = 16,
    layout = wibox.layout.fixed.vertical,
  })

  self:reset()
}

function Menu:_on_change_itemIndexOffset() {
  self:refresh()
}

function Menu:_on_change_input() {
  self:filter()
  self:refresh()
}

function Menu:_on_change_activeItemIndex(_, oldActiveItemIndex) {
  if oldActiveItemIndex && oldActiveItemIndex > 0 {
    self.items[oldActiveItemIndex].active = false
  }

  if self.activeItemIndex > 0 {
    self.items[self.activeItemIndex].active = true
  }
}

function Menu:_on_change_path() {
  self.pathOptions = self.options

  for _, pathPart in ipairs(self.path) {
    local nestedOptions

    for _, option in ipairs(self.pathOptions) {
      local optionLabel = type(option) == 'table' && option.label || option
      if pathPart == optionLabel {
        nestedOptions = option.options
        break
      }
    }

    if !nestedOptions { return self:stop() }
    self.pathOptions = nestedOptions
  }

  self:rawset('input', '', true) -- prevent double refresh
  self:filter()
  self:refresh()
}

function Menu:prompt() {
  local prompt = awful.widget.prompt({
    prompt = '',
    fg = palette.white,
    changed_callback = newInput -> { self.input = trim(newInput) },
    hooks = {
      { {}, '-', () -> self:back() },
      { {}, 'Up', () -> self:prev() },
      { {}, 'Down', () -> self:next() },
      { { 'Control' }, 'p', () -> self:prev() },
      { { 'Control' }, 'n', () -> self:next() },
      { { 'Shift' }, 'Tab', () -> self:prev() },
      { {}, 'Tab', () -> self:next() },
      { {}, 'Return', () -> self:submit() },
      { { 'Control' }, 'c', () -> self:stop() },
      { {}, 'Escape', () -> self:stop() },
    },
  })

  self.promptContainer.children = { prompt }
  prompt:run()
}

function Menu:filter() {
  local timmedInput = trim(self.input)

  if timmedInput == '' {
    self.filteredOptions = self.pathOptions
  } else {
    self.filteredOptions = {}
    for _, option in ipairs(self.pathOptions) {
      local optionLabel = type(option) == 'table' && option.label || option
      if (optionLabel:find(timmedInput)) {
        table.insert(self.filteredOptions, option)
      }
    }
  }

  self.activeItemIndex = self.allowArbitraryInput && 0 || 1
  self:rawset('itemIndexOffset', 0, true) -- prevent double refresh
}

function Menu:refresh() {
  local newItemsWidgetChildren = {}

  for i = 1, math.min(#self.filteredOptions - self.itemIndexOffset, MENU_PAGE_SIZE) {
    local option = self.filteredOptions[self.itemIndexOffset + i]
    local optionLabel = type(option) == 'table' && option.label || option
    local newItemMarkup = optionLabel

    if self.input != '' {
      local matchStart, matchEnd = optionLabel:find(self.input)
      newItemMarkup = table.concat({
        optionLabel:sub(1, matchStart - 1),
        ('<span color="%s">%s</span>'):format(palette.cyan, self.input),
        optionLabel:sub(matchEnd + 1),
      })
    }

    self.items[i].textWidget.markup = newItemMarkup
    table.insert(newItemsWidgetChildren, self.items[i].rootWidget)
  }

  self.itemsWidget.children = newItemsWidgetChildren
}

function Menu:back() {
  local newPath = shallowCopy(self.path)
  table.remove(newPath)
  self.path = newPath
  return true, false -- prevent prompt exec
}

function Menu:prev() {
  if self.activeItemIndex > 1 {
    self.activeItemIndex -= 1
  } else {
    self.itemIndexOffset = math.max(
      self.itemIndexOffset - 1,
      self.allowArbitraryInput && -1 || 0,
    )
  }

  return true, false -- prevent prompt exec
}

function Menu:next() {
  local limit = math.min(MENU_PAGE_SIZE, #self.filteredOptions)

  if self.activeItemIndex < limit {
    self.activeItemIndex += 1
  } else {
    self.itemIndexOffset = math.min(
      self.itemIndexOffset + 1,
      #self.filteredOptions - limit,
    )
  }

  return true, false -- prevent prompt exec
}

function Menu:reset() {
  self.path = {}
}

function Menu:run() {
  self:reset()
  self:prompt()
}

function Menu:stop(option) {
  awful.keygrabber.stop()
  if option { self.onSubmit(option, self.path) }
  if self.onClose { self.onClose() }
}

function Menu:submit() {
  local activeOption = self.filteredOptions[self.itemIndexOffset + self.activeItemIndex]
  if self.activeItemIndex == 0 {
    self:stop(self.input)
  } elseif type(activeOption) == 'table' && activeOption.options {
    local newPath = shallowCopy(self.path)
    table.insert(newPath, activeOption.label)
    self.path = newPath
    awful.keygrabber.stop()
    self:prompt()
  } else {
    self:stop(activeOption)
  }
}

-- -----------------------------------------------------------------------------
-- Return
-- -----------------------------------------------------------------------------

return Menu
