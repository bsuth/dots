local awful = require('awful')
local gears = require('gears')
local wibox = require('wibox')
local Object = require('core.Object')
local { palette } = require('core.theme')
local { trim } = require('core.utils')

local MENU_ITEM_WIDTH = 384
local MENU_ITEM_HEIGHT = 60
local MENU_PAGE_SIZE = 5
local SCROLLBAR_WIDTH = 4

function create_menu_item_widget(content_widget) {
  return wibox.widget({
    {
      {
        content_widget,
        left = 16,
        right = 16,
        widget = wibox.container.margin,
      },
      content_fill_horizontal = true,
      widget = wibox.container.place,
    },
    fg = palette.white,
    bg = palette.dark_gray,
    forced_width = MENU_ITEM_WIDTH,
    forced_height = MENU_ITEM_HEIGHT,
    widget = wibox.container.background,
  })
}

-- -----------------------------------------------------------------------------
-- MenuItem
-- -----------------------------------------------------------------------------

local MenuItem = {}

function MenuItem:_init(props = {}) {
  self.text_widget = wibox.widget({
    markup = props.markup,
    widget = wibox.widget.textbox,
  })

  self.suffix_widget = wibox.widget({
    text = '',
    widget = wibox.widget.textbox,
  })

  self.root_widget = create_menu_item_widget({
    self.text_widget,
    { widget = wibox.container.background },
    self.suffix_widget,
    spacing = 8,
    layout = wibox.layout.align.horizontal,
  })

  if props.active {
    self.root_widget.bg = palette.light_gray
  }
}

function MenuItem:_get_markup() {
  return self.text_widget.markup
}

function MenuItem:_set_markup(new_markup) {
  self.text_widget.markup = new_markup
}

function MenuItem:_get_active() {
  return !!gears.color.to_rgba_string(self.root_widget.bg):find(palette.light_gray)
}

function MenuItem:_set_active(new_active) {
  self.root_widget.bg = new_active && palette.light_gray || palette.dark_gray
}

-- -----------------------------------------------------------------------------
-- Menu
-- -----------------------------------------------------------------------------

local Menu = {}

function Menu:_init(props) {
  self.props = props

  self.items = {}
  self.items_widget = wibox.widget({ layout = wibox.layout.fixed.vertical })
  for i = 1, MENU_PAGE_SIZE {
    local dmenu_item = Object(MenuItem, { markup = '' })
    table.insert(self.items, dmenu_item)
    self.items_widget:add(dmenu_item.root_widget)
  }

  self.prompt_container = wibox.widget({
    {
      -- dummy textbox to prevent container from collapsing
      markup = '',
      widget = wibox.widget.textbox,
    },
    layout = wibox.layout.fixed.horizontal,
  })

  self.scroll_thumb_widget = wibox.widget({
    forced_width = SCROLLBAR_WIDTH,
    bg = palette.cyan,
    widget = wibox.container.background,
  })

  self.scrollbar_widget = wibox.widget({ layout = wibox.layout.manual })
  self.scrollbar_widget:add_at(self.scroll_thumb_widget, { x = 0, y = 0 })

  self.root_widget = wibox.widget({
    {
      {
        create_menu_item_widget(self.prompt_container),
        shape_border_width = 1,
        shape_border_color = palette.cyan,
        bg = palette.dark_gray,
        widget = wibox.container.background,
      },
      {
        self.items_widget,
        shape_border_width = 1,
        shape_border_color = palette.cyan,
        bg = palette.dark_gray,
        widget = wibox.container.background,
      },
      spacing = 8,
      layout = wibox.layout.fixed.vertical,
    },
    {
      self.scrollbar_widget,
      top = MENU_ITEM_HEIGHT + 8,
      forced_width = SCROLLBAR_WIDTH,
      forced_height = MENU_ITEM_HEIGHT * MENU_PAGE_SIZE,
      widget = wibox.container.margin,
    },
    spacing = 4,
    layout = wibox.layout.fixed.horizontal,
  })

  self.path = {}
  self.options = props.options
}

function Menu:_on_change_item_index_offset() {
  self:refresh()
}

function Menu:_on_change_input() {
  self:filter()
}

function Menu:_on_change_options() {
  self:rawset('input', '', true)
  self:filter() -- force filter + refresh, in case input isnt actually changing
}

function Menu:_on_change_active_item_index(_, old_active_item_index) {
  if old_active_item_index && old_active_item_index > 0 {
    self.items[old_active_item_index].active = false
  }

  if self.active_item_index > 0 {
    self.items[self.active_item_index].active = true
  }
}

function Menu:filter() {
  local trimmed_input = trim(self.input)

  if trimmed_input == '' {
    self.filtered_options = self.options
  } else {
    self.filtered_options = {}
    for _, option in ipairs(self.options) {
      local option_label = type(option) == 'table' && option.label || option
      if (option_label:find(trimmed_input)) {
        table.insert(self.filtered_options, option)
      }
    }
  }

  self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
  self:rawset('item_index_offset', 0, true)
  self:refresh() -- force refresh, in case input isnt actually changing
}

function Menu:refresh() {
  local new_items_widget_children = {}
  local num_filtered_options = #self.filtered_options

  if num_filtered_options <= MENU_PAGE_SIZE {
    self.scrollbar_widget.visible = false
  } else {
    local num_scroll = num_filtered_options - MENU_PAGE_SIZE + 1
    local scroll_increment = (MENU_ITEM_HEIGHT * MENU_PAGE_SIZE) / num_scroll
    self.scroll_thumb_widget.forced_height = scroll_increment
    self.scrollbar_widget:move_widget(self.scroll_thumb_widget, { x = 0, y = self.item_index_offset * scroll_increment })
    self.scrollbar_widget.visible = true
  }

  for i = 1, math.min(num_filtered_options - self.item_index_offset, MENU_PAGE_SIZE) {
    local option = self.filtered_options[self.item_index_offset + i]
    local option_label = type(option) == 'table' && option.label || option
    local new_item_markup = option_label

    if self.input != '' {
      local match_start, match_end = option_label:find(self.input)
      new_item_markup = table.concat({
        option_label:sub(1, match_start - 1),
        ('<span color="%s">%s</span>'):format(palette.cyan, self.input),
        option_label:sub(match_end + 1),
      })
    }

    self.items[i].text_widget.markup = new_item_markup
    self.items[i].suffix_widget.text = (type(option) == 'table' && option.options) && 'âžœ' || ''
    table.insert(new_items_widget_children, self.items[i].root_widget)
  }

  self.items_widget.children = new_items_widget_children
}

function Menu:prompt() {
  -- Use `return true, false` to prevent prompt from exiting
  -- https://awesomewm.org/doc/api/libraries/awful.prompt.html#hook
  local on_back = () -> { self:back(); return true, false }
  local on_prev = () -> { self:prev(); return true, false }
  local on_next = () -> { self:next(); return true, false }

  local prompt = awful.widget.prompt({
    prompt = '',
    fg = palette.white,
    changed_callback = new_input -> { self.input = trim(new_input) },
    hooks = {
      { {}, '-', on_back },
      { {}, 'Up', on_prev },
      { {}, 'Down', on_next },
      { { 'Control' }, 'p', on_prev },
      { { 'Control' }, 'n', on_next },
      { { 'Shift' }, 'Tab', on_prev },
      { {}, 'Tab', on_next },
      { {}, 'Return', () -> self:submit() },
      { { 'Control' }, 'c', () -> self:stop() },
      { {}, 'Escape', () -> self:stop() },
    },
  })

  self.prompt_container.children = { self.prompt_container.children[1], prompt }
  prompt:run()
}

function Menu:back() {
  if #self.path > 0 {
    self.options = table.remove(self.path)
  }
}

function Menu:prev() {
  if self.active_item_index > (self.props.allow_arbitrary_input && 0 || 1) {
    self.active_item_index -= 1
  } elseif self.item_index_offset > 0 {
    self.item_index_offset -= 1
  } else {
    local num_filtered_options = #self.filtered_options
    local limit = math.min(MENU_PAGE_SIZE, num_filtered_options)
    self.active_item_index = limit
    self.item_index_offset = num_filtered_options - limit
  }
}

function Menu:next() {
  local num_filtered_options = #self.filtered_options
  local limit = math.min(MENU_PAGE_SIZE, num_filtered_options)

  if self.active_item_index < limit {
    self.active_item_index += 1
  } elseif self.item_index_offset < num_filtered_options - limit {
    self.item_index_offset += 1
  } else {
    self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
    self.item_index_offset = 0
  }
}

function Menu:run() {
  self:prompt()
  if self.options != self.props.options {
    self.options = self.props.options
  } else {
    self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
    self.item_index_offset = 0
  }
}

function Menu:stop(option) {
  awful.keygrabber.stop()
  if option { self.props.on_submit(option, self.path) }
  if self.props.on_close { self.props.on_close() }
  self.input = ''
}

function Menu:submit() {
  local active_option = self.filtered_options[self.item_index_offset + self.active_item_index]
  if self.active_item_index == 0 {
    self:stop(self.input)
  } elseif type(active_option) == 'table' && active_option.options {
    table.insert(self.path, self.options)
    self.options = active_option.options
    awful.keygrabber.stop()
    self:prompt()
  } else {
    self:stop(active_option)
  }
}

-- -----------------------------------------------------------------------------
-- Return
-- -----------------------------------------------------------------------------

return Menu
