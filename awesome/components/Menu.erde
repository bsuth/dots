local awful = require('awful')
local gears = require('gears')
local wibox = require('wibox')
local Class = require('core.Class')
local { palette } = require('core.theme')
local { trim } = require('core.utils')
local Prompt = require('components.Prompt')

local MENU_ITEM_WIDTH = 384
local MENU_ITEM_HEIGHT = 60
local MENU_PAGE_SIZE = 5
local MENU_SELECTED_BG = palette.light_gray
local MENU_UNSELECTED_BG = '#1A1A1A'

function create_menu_item_widget(content_widget) {
  return wibox.widget({
    {
      {
        content_widget,
        left = 16,
        right = 16,
        widget = wibox.container.margin,
      },
      content_fill_horizontal = true,
      widget = wibox.container.place,
    },
    fg = palette.white,
    bg = MENU_UNSELECTED_BG,
    forced_width = MENU_ITEM_WIDTH,
    forced_height = MENU_ITEM_HEIGHT,
    widget = wibox.container.background,
  })
}

-- -----------------------------------------------------------------------------
-- MenuItem
-- -----------------------------------------------------------------------------

local MenuItem = Class()

function MenuItem:_init(props = {}) {
  self.text_widget = wibox.widget({
    markup = props.markup,
    widget = wibox.widget.textbox,
  })

  self.suffix_widget = wibox.widget({
    text = '',
    widget = wibox.widget.textbox,
  })

  self.root_widget = create_menu_item_widget({
    self.text_widget,
    { widget = wibox.container.background },
    self.suffix_widget,
    spacing = 8,
    layout = wibox.layout.align.horizontal,
  })

  if props.active {
    self.root_widget.bg = palette.light_gray
  }
}

function MenuItem:_get_markup() {
  return self.text_widget.markup
}

function MenuItem:_set_markup(new_markup) {
  self.text_widget.markup = new_markup
}

function MenuItem:_get_active() {
  return !!gears.color.to_rgba_string(self.root_widget.bg):find(palette.light_gray)
}

function MenuItem:_set_active(new_active) {
  self.root_widget.bg = new_active && MENU_SELECTED_BG || MENU_UNSELECTED_BG
}

-- -----------------------------------------------------------------------------
-- Menu
-- -----------------------------------------------------------------------------

local Menu = Class()

function Menu:_init(props) {
  self.props = props

  self.items = {}
  self.items_widget = wibox.widget({ layout = wibox.layout.fixed.vertical })
  for i = 1, MENU_PAGE_SIZE {
    local dmenu_item = MenuItem({ markup = '' })
    table.insert(self.items, dmenu_item)
    self.items_widget:add(dmenu_item.root_widget)
  }

  self.prompt_container = wibox.widget({
    {
      -- dummy textbox to prevent container from collapsing
      markup = '',
      widget = wibox.widget.textbox,
    },
    layout = wibox.layout.fixed.horizontal,
  })

  self.root_widget = wibox.widget({
    {
      create_menu_item_widget(self.prompt_container),
      shape_border_width = 1,
      shape_border_color = palette.white,
      widget = wibox.container.background,
    },
    {
      self.items_widget,
      shape_border_width = 1,
      shape_border_color = palette.white,
      widget = wibox.container.background,
    },
    spacing = 8,
    layout = wibox.layout.fixed.vertical,
  })

  self.path = {}
  self.options = props.options

  -- Initialize active_item_index to 0 until we actually start running
  self.active_item_index = 0
}

function Menu:_on_change_item_index_offset() {
  self:refresh()
}

function Menu:_on_change_input() {
  self:filter()
}

function Menu:_on_change_options() {
  self:rawset('input', '', true)
  self:filter() -- force filter + refresh, in case input isnt actually changing
}

function Menu:_on_change_active_item_index(_, old_active_item_index) {
  if old_active_item_index && old_active_item_index > 0 {
    self.items[old_active_item_index].active = false
  }

  if self.active_item_index > 0 {
    self.items[self.active_item_index].active = true
  }
}

function Menu:filter() {
  local trimmed_input = trim(self.input)

  if trimmed_input == '' {
    self.filtered_options = self.options
  } else {
    self.filtered_options = {}
    for _, option in ipairs(self.options) {
      local option_label = type(option) == 'table' && option.label || option
      if (option_label:find(trimmed_input)) {
        table.insert(self.filtered_options, option)
      }
    }
  }

  self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
  self:rawset('item_index_offset', 0, true)
  self:refresh() -- force refresh, in case input isnt actually changing
}

function Menu:refresh() {
  local new_items_widget_children = {}
  local num_filtered_options = #self.filtered_options

  for i = 1, math.min(num_filtered_options - self.item_index_offset, MENU_PAGE_SIZE) {
    local option = self.filtered_options[self.item_index_offset + i]
    local option_label = type(option) == 'table' && option.label || option
    local new_item_markup = option_label

    if self.input != '' {
      local match_start, match_end = option_label:find(self.input)
      new_item_markup = table.concat({
        option_label:sub(1, match_start - 1),
        ('<span color="%s">%s</span>'):format(palette.cyan, self.input),
        option_label:sub(match_end + 1),
      })
    }

    self.items[i].text_widget.markup = new_item_markup
    self.items[i].suffix_widget.text = (type(option) == 'table' && option.options) && 'âžœ' || ''
    table.insert(new_items_widget_children, self.items[i].root_widget)
  }

  self.items_widget.children = new_items_widget_children
}

function Menu:run_prompt() {
  -- Use `return true, false` to prevent prompt from exiting
  -- https://awesomewm.org/doc/api/libraries/awful.prompt.html#hook
  local on_back = () -> { self:back(); return true, false }
  local on_prev = () -> { self:prev(); return true, false }
  local on_next = () -> { self:next(); return true, false }

  self.prompt = Prompt({
    on_cancel = () -> self:stop(),
    on_submit = () -> self:submit(),
    on_user_change = () -> { self.input = trim(self.prompt.text) },
    keybindings = {
      { {}, '-', on_back },
      { {}, 'Up', on_prev },
      { {}, 'Down', on_next },
      { { 'Control' }, 'p', on_prev },
      { { 'Control' }, 'n', on_next },
      { { 'Shift' }, 'Tab', on_prev },
      { {}, 'Tab', on_next },
    },
  })

  self.prompt_container.children = {
    self.prompt_container.children[1],
    self.prompt.root_widget,
  }

  self.prompt:start()
}

function Menu:back() {
  if #self.path > 0 {
    self.options = table.remove(self.path)
  }
}

function Menu:prev() {
  if self.active_item_index > (self.props.allow_arbitrary_input && 0 || 1) {
    self.active_item_index -= 1
  } elseif self.item_index_offset > 0 {
    self.item_index_offset -= 1
  } else {
    local num_filtered_options = #self.filtered_options
    local limit = math.min(MENU_PAGE_SIZE, num_filtered_options)
    self.active_item_index = limit
    self.item_index_offset = num_filtered_options - limit
  }
}

function Menu:next() {
  local num_filtered_options = #self.filtered_options
  local limit = math.min(MENU_PAGE_SIZE, num_filtered_options)

  if self.active_item_index < limit {
    self.active_item_index += 1
  } elseif self.item_index_offset < num_filtered_options - limit {
    self.item_index_offset += 1
  } else {
    self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
    self.item_index_offset = 0
  }
}

function Menu:run() {
  self:run_prompt()
  if self.options != self.props.options {
    self.options = self.props.options
  } else {
    self.active_item_index = self.props.allow_arbitrary_input && 0 || 1
    self.item_index_offset = 0
  }
}

function Menu:stop(option) {
  if option && self.props.on_submit { self.props.on_submit(option, self.path) }
  if !option && self.props.on_cancel { self.props.on_cancel() }
  if self.props.on_close { self.props.on_close() }
  self.input = ''
  self.active_item_index = 0
  self.prompt_container.children = { self.prompt_container.children[1] }
}

function Menu:submit() {
  local active_option = self.filtered_options[self.item_index_offset + self.active_item_index]
  if self.active_item_index == 0 {
    self:stop(self.input)
  } elseif type(active_option) == 'table' && active_option.options {
    table.insert(self.path, self.options)
    self.options = active_option.options
    self:run_prompt()
  } else {
    self:stop(active_option)
  }
}

-- -----------------------------------------------------------------------------
-- Return
-- -----------------------------------------------------------------------------

return Menu
