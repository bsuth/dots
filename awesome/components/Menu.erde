local awful = require('awful')
local gears = require('gears')
local wibox = require('wibox')
local Object = require('core.Object')
local { palette } = require('core.theme')
local { shallowCopy, trim } = require('core.utils')

local MENU_ITEM_WIDTH = 384
local MENU_ITEM_HEIGHT = 60
local MENU_PAGE_SIZE = 5
local SCROLLBAR_WIDTH = 4

-- -----------------------------------------------------------------------------
-- MenuItemWidget
-- -----------------------------------------------------------------------------

function createMenuItemWidget(contentWidget) {
  return wibox.widget({
    {
      {
        contentWidget,
        left = 16,
        right = 16,
        widget = wibox.container.margin,
      },
      content_fill_horizontal = true,
      widget = wibox.container.place,
    },
    fg = palette.white,
    bg = palette.darkGray,
    forced_width = MENU_ITEM_WIDTH,
    forced_height = MENU_ITEM_HEIGHT,
    widget = wibox.container.background,
  })
}

-- -----------------------------------------------------------------------------
-- MenuItem
--
-- props? = {
--   markup = string,
--   active? = boolean,
-- }
-- -----------------------------------------------------------------------------

local MenuItem = {}

function MenuItem:_init(props = {}) {
  self.textWidget = wibox.widget({
    markup = props.markup,
    widget = wibox.widget.textbox,
  })

  self.suffixWidget = wibox.widget({
    text = '',
    widget = wibox.widget.textbox,
  })

  self.rootWidget = createMenuItemWidget({
    self.textWidget,
    { widget = wibox.container.background },
    self.suffixWidget,
    spacing = 8,
    layout = wibox.layout.align.horizontal,
  })

  if props.active {
    self.rootWidget.bg = palette.lightGray
  }
}

function MenuItem:_get_markup() {
  return self.textWidget.markup
}

function MenuItem:_set_markup(newMarkup) {
  self.textWidget.markup = newMarkup
}

function MenuItem:_get_active() {
  return !!gears.color.to_rgba_string(self.rootWidget.bg):find(palette.lightGray)
}

function MenuItem:_set_active(newActive) {
  self.rootWidget.bg = newActive && palette.lightGray || palette.darkGray
}

-- -----------------------------------------------------------------------------
-- Menu
--
-- props = {
--   options<1> = (string | { label = string, options = <1> })[]
--   onSubmit = (option: string) -> void,
--   onClose? = () -> void,
--   allowArbitraryInput? = boolean,
--   defaultPromptText? = string,
-- }
-- -----------------------------------------------------------------------------

local Menu = {}

function Menu:_init(props) {
  self.props = props

  self.items = {}
  self.itemsWidget = wibox.widget({ layout = wibox.layout.fixed.vertical })
  for i = 1, MENU_PAGE_SIZE {
    local dmenuItem = Object(MenuItem, { markup = '' })
    table.insert(self.items, dmenuItem)
    self.itemsWidget:add(dmenuItem.rootWidget)
  }

  self.promptContainer = wibox.widget({
    {
      -- dummy textbox to prevent container from collapsing
      markup = '',
      widget = wibox.widget.textbox,
    },
    layout = wibox.layout.fixed.horizontal,
  })

  self.scrollThumbWidget = wibox.widget({
    forced_width = SCROLLBAR_WIDTH,
    bg = palette.cyan,
    widget = wibox.container.background,
  })

  self.scrollbarWidget = wibox.widget({ layout = wibox.layout.manual })
  self.scrollbarWidget:add_at(self.scrollThumbWidget, { x = 0, y = 0 })

  self.rootWidget = wibox.widget({
    {
      {
        createMenuItemWidget(self.promptContainer),
        shape_border_width = 1,
        shape_border_color = palette.cyan,
        bg = palette.darkGray,
        widget = wibox.container.background,
      },
      {
        self.itemsWidget,
        shape_border_width = 1,
        shape_border_color = palette.cyan,
        bg = palette.darkGray,
        widget = wibox.container.background,
      },
      spacing = 8,
      layout = wibox.layout.fixed.vertical,
    },
    {
      self.scrollbarWidget,
      top = MENU_ITEM_HEIGHT + 8,
      forced_width = SCROLLBAR_WIDTH,
      forced_height = MENU_ITEM_HEIGHT * MENU_PAGE_SIZE,
      widget = wibox.container.margin,
    },
    spacing = 4,
    layout = wibox.layout.fixed.horizontal,
  })

  self.path = {}
  self.options = props.options
}

function Menu:_on_change_itemIndexOffset() {
  self:refresh()
}

function Menu:_on_change_input() {
  self:filter()
}

function Menu:_on_change_options() {
  self:rawset('input', '', true)
  self:filter() -- force filter + refresh, in case input isnt actually changing
}

function Menu:_on_change_activeItemIndex(_, oldActiveItemIndex) {
  if oldActiveItemIndex && oldActiveItemIndex > 0 {
    self.items[oldActiveItemIndex].active = false
  }

  if self.activeItemIndex > 0 {
    self.items[self.activeItemIndex].active = true
  }
}

function Menu:filter() {
  local trimmedInput = trim(self.input)

  if trimmedInput == '' {
    self.filteredOptions = self.options
  } else {
    self.filteredOptions = {}
    for _, option in ipairs(self.options) {
      local optionLabel = type(option) == 'table' && option.label || option
      if (optionLabel:find(trimmedInput)) {
        table.insert(self.filteredOptions, option)
      }
    }
  }

  self.activeItemIndex = self.props.allowArbitraryInput && 0 || 1
  self:rawset('itemIndexOffset', 0, true)
  self:refresh() -- force refresh, in case input isnt actually changing
}

function Menu:refresh() {
  local newItemsWidgetChildren = {}
  local numFilteredOptions = #self.filteredOptions

  if numFilteredOptions <= MENU_PAGE_SIZE {
    self.scrollbarWidget.visible = false
  } else {
    local numScroll = numFilteredOptions - MENU_PAGE_SIZE + 1
    local scrollIncrement = (MENU_ITEM_HEIGHT * MENU_PAGE_SIZE) / numScroll
    self.scrollThumbWidget.forced_height = scrollIncrement
    self.scrollbarWidget:move_widget(self.scrollThumbWidget, { x = 0, y = self.itemIndexOffset * scrollIncrement })
    self.scrollbarWidget.visible = true
  }

  for i = 1, math.min(numFilteredOptions - self.itemIndexOffset, MENU_PAGE_SIZE) {
    local option = self.filteredOptions[self.itemIndexOffset + i]
    local optionLabel = type(option) == 'table' && option.label || option
    local newItemMarkup = optionLabel

    if self.input != '' {
      local matchStart, matchEnd = optionLabel:find(self.input)
      newItemMarkup = table.concat({
        optionLabel:sub(1, matchStart - 1),
        ('<span color="%s">%s</span>'):format(palette.cyan, self.input),
        optionLabel:sub(matchEnd + 1),
      })
    }

    self.items[i].textWidget.markup = newItemMarkup
    self.items[i].suffixWidget.text = (type(option) == 'table' && option.options) && 'âžœ' || ''
    table.insert(newItemsWidgetChildren, self.items[i].rootWidget)
  }

  self.itemsWidget.children = newItemsWidgetChildren
}

function Menu:prompt() {
  -- Use `return true, false` to prevent prompt from exiting
  -- https://awesomewm.org/doc/api/libraries/awful.prompt.html#hook
  local onBack = () -> { self:back(); return true, false }
  local onPrev = () -> { self:prev(); return true, false }
  local onNext = () -> { self:next(); return true, false }

  local prompt = awful.widget.prompt({
    prompt = '',
    fg = palette.white,
    changed_callback = newInput -> { self.input = trim(newInput) },
    hooks = {
      { {}, '-', onBack },
      { {}, 'Up', onPrev },
      { {}, 'Down', onNext },
      { { 'Control' }, 'p', onPrev },
      { { 'Control' }, 'n', onNext },
      { { 'Shift' }, 'Tab', onPrev },
      { {}, 'Tab', onNext },
      { {}, 'Return', () -> self:submit() },
      { { 'Control' }, 'c', () -> self:stop() },
      { {}, 'Escape', () -> self:stop() },
    },
  })

  self.promptContainer.children = { self.promptContainer.children[1], prompt }
  prompt:run()
}

function Menu:back() {
  if #self.path > 0 {
    self.options = table.remove(self.path)
  }
}

function Menu:prev() {
  if self.activeItemIndex > (self.props.allowArbitraryInput && 0 || 1) {
    self.activeItemIndex -= 1
  } elseif self.itemIndexOffset > 0 {
    self.itemIndexOffset -= 1
  } else {
    local numFilteredOptions = #self.filteredOptions
    local limit = math.min(MENU_PAGE_SIZE, numFilteredOptions)
    self.activeItemIndex = limit
    self.itemIndexOffset = numFilteredOptions - limit
  }
}

function Menu:next() {
  local numFilteredOptions = #self.filteredOptions
  local limit = math.min(MENU_PAGE_SIZE, numFilteredOptions)

  if self.activeItemIndex < limit {
    self.activeItemIndex += 1
  } elseif self.itemIndexOffset < numFilteredOptions - limit {
    self.itemIndexOffset += 1
  } else {
    self.activeItemIndex = self.props.allowArbitraryInput && 0 || 1
    self.itemIndexOffset = 0
  }
}

function Menu:run() {
  self:prompt()
  if self.options != self.props.options {
    self.options = self.props.options
  } else {
    self.activeItemIndex = self.props.allowArbitraryInput && 0 || 1
    self.itemIndexOffset = 0
  }
}

function Menu:stop(option) {
  awful.keygrabber.stop()
  if option { self.props.onSubmit(option, self.path) }
  if self.props.onClose { self.props.onClose() }
  self.input = ''
}

function Menu:submit() {
  local activeOption = self.filteredOptions[self.itemIndexOffset + self.activeItemIndex]
  if self.activeItemIndex == 0 {
    self:stop(self.input)
  } elseif type(activeOption) == 'table' && activeOption.options {
    table.insert(self.path, self.options)
    self.options = activeOption.options
    awful.keygrabber.stop()
    self:prompt()
  } else {
    self:stop(activeOption)
  }
}

-- -----------------------------------------------------------------------------
-- Return
-- -----------------------------------------------------------------------------

return Menu
