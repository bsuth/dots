-- TODO: This is unused, but saved for future use. Needs refactor?

function DialWidget(opts) {
  local dialWidget = wibox.widget({
    {
      {
        opts.widget,
        widget = wibox.container.place,
      },
      margins = 16,
      widget = wibox.container.margin,
    },
    bgimage = (_, cr, width, height) -> {
      local m = math.min(width, height)

      local bg = hex2rgb(palette.lightGray)
      cr:set_source_rgb(bg[1], bg[2], bg[3])
      gears.shape.arc(cr, m, m, DIAL_BORDER_WIDTH, 0, 2 * math.pi)
      cr:fill()

      if opts.model.percent && opts.model.percent > 0 {
        local fg = hex2rgb(opts.color)
        cr:set_source_rgb(fg[1], fg[2], fg[3])

        -- 98 is close enough so round (plus, battery percent never reaches
        -- 100% on some computers)
        if opts.model.percent < 98 {
          -- If (thetaEnd - thetaStart) is too small, then cairo will shift
          -- theta_end slightly in an attempt to draw something over nothing.
          -- This causes a sort of "jump" when the percent gets to low, so to
          -- avoid this, we always draw a small circle centered at theta_end
          -- to mimic the rounded end, and just draw a rounded start for the
          -- actual arc.
          cr:arc(
            m / 2,
            DIAL_BORDER_WIDTH / 2,
            DIAL_BORDER_WIDTH / 2,
            0,
            2 * math.pi
          )

          local thetaEnd = 3 * math.pi / 2
          local thetaStart = thetaEnd
            - (opts.model.percent / 100) * (2 * math.pi)

          gears.shape.arc(
            cr,
            m,
            m,
            DIAL_BORDER_WIDTH,
            thetaStart,
            thetaEnd,
            true,
            false
          )
        } else {
          gears.shape.arc(cr, m, m, DIAL_BORDER_WIDTH, 0, 2 * math.pi)
        }
      }

      cr:fill()
    },
    widget = wibox.container.background,
  })

  opts.model:connect_signal('update', () -> dialWidget:emit_signal('widget::redraw_needed'))
  return dialWidget
}
