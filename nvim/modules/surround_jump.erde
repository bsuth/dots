local OPEN_SURROUND_CHARS = {
  ['('] = true,
  ['{'] = true,
  ['['] = true,
}

local CLOSE_SURROUND_CHARS = {
  [')'] = true,
  ['}'] = true,
  [']'] = true,
}

function get_cursor_char() {
  local [ _, line, column ] = vim.fn.getpos('.')
  return vim.fn.getline(line):sub(column, column)
}

function prev_chars() {
  local [ _, line, column ] = vim.fn.getpos('.')
  local line_chars = vim.fn.getline(line)

  local iterator = () -> {
    if column > 1 {
      column -= 1
      return line, column, line_chars:sub(column, column)
    } elseif line > 1 {
      line -= 1
      line_chars = vim.fn.getline(line)
      column = #line_chars
      return line, column, line_chars:sub(column, column)
    }
  }

  return iterator, vimpos
}

function next_chars() {
  local [ _, line, column ] = vim.fn.getpos('.')
  local line_chars = vim.fn.getline(line)
  local line_limit, column_limit = vim.fn.line('$'), #line_chars

  local iterator = () -> {
    if column < column_limit {
      column += 1
      return line, column, line_chars:sub(column, column)
    } elseif line < line_limit {
      line += 1
      line_chars = vim.fn.getline(line)
      column, column_limit = 1, #line_chars
      return line, column, line_chars:sub(column, column)
    }
  }

  return iterator, vimpos
}

function surround_jump_back() {
  if CLOSE_SURROUND_CHARS[get_cursor_char()] {
    vim.cmd('normal %')
    return
  }

  local _, start_line, start_column = unpack(vim.fn.getcurpos())
  local jump_line, jump_column

  for line, column, char in prev_chars() {
    if OPEN_SURROUND_CHARS[char] {
      jump_line, jump_column = line, column
      break
    } elseif CLOSE_SURROUND_CHARS[char] {
      vim.fn.setcursorcharpos(line, column)
      vim.cmd('keepjumps normal %')
      _, jump_line, jump_column = unpack(vim.fn.getcurpos())
      vim.fn.setcursorcharpos(start_line, start_column)
      break
    }
  }

  if jump_line && jump_column {
    -- use `lineGcol|` over `setcursorcharpos` so we can push to the jumplist
    vim.cmd("normal {jump_line}G{jump_column}|")
  }
}

function surround_jump_forward() {
  if OPEN_SURROUND_CHARS[get_cursor_char()] {
    vim.cmd('normal %')
    return
  }

  local _, start_line, start_column = unpack(vim.fn.getcurpos())
  local jump_line, jump_column

  for line, column, char in next_chars() {
    if CLOSE_SURROUND_CHARS[char] {
      jump_line, jump_column = line, column
      break
    } elseif OPEN_SURROUND_CHARS[char] {
      vim.fn.setcursorcharpos(line, column)
      vim.cmd('keepjumps normal %')
      _, jump_line, jump_column = unpack(vim.fn.getcurpos())
      vim.fn.setcursorcharpos(start_line, start_column)
      break
    }
  }

  if jump_line && jump_column {
    -- use `lineGcol|` over `setcursorcharpos` so we can push to the jumplist
    vim.cmd("normal {jump_line}G{jump_column}|")
  }
}

vim.keymap.set('n', '(', surround_jump_back)
vim.keymap.set('v', '(', surround_jump_back)
vim.keymap.set('n', ')', surround_jump_forward)
vim.keymap.set('v', ')', surround_jump_forward)
