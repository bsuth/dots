local { TERM_PATTERNS } = require('constants')

local CWD_CACHE = {}

local CWD_TRACK_BLACKLIST = {
  '^term://',
  '^fugitive://',
}

local CWD_TRACK_BUFNAME_FILTER = {
  -- TODO: have suda inject this
  '^suda://',
}

function get_bufname() {
  local bufname = vim.api.nvim_buf_get_name(0)

  for _, pattern in ipairs(CWD_TRACK_BUFNAME_FILTER) {
    bufname = bufname:gsub(pattern, '')
  }

  return bufname
}

function is_blacklist_bufname(bufname) {
  for _, pattern in ipairs(CWD_TRACK_BLACKLIST) {
    if bufname:match(pattern) {
      return true
    }
  }
}

-- Do not make this local! zsh needs this for cd hook in nested terminal.
global function save_term_cwd() {
  local bufname = get_bufname()
  if !is_blacklist_bufname(bufname) {
    CWD_CACHE[bufname] = vim.fn.getcwd()
  }
}

vim.api.nvim_create_autocmd('BufEnter', {
  group = 'bsuth',
  pattern = '*',
  callback = () -> {
    local bufname = get_bufname()
    if bufname:match('^term://') {
      if CWD_CACHE[bufname] != nil {
        vim.cmd('cd ' .. CWD_CACHE[bufname])
      }
    } elseif !is_blacklist_bufname(bufname) {
      vim.cmd('cd ' .. vim.fn.fnamemodify(bufname, ':p:h'))
      if vim.api.nvim_buf_get_option(0, 'filetype') == 'dirvish' {
        vim.cmd('Dirvish') -- refresh dirvish after cd
      }
    }
  },
})

vim.api.nvim_create_autocmd('TermOpen', {
  group = 'bsuth',
  pattern = TERM_PATTERNS,
  callback = save_term_cwd,
})

vim.api.nvim_create_autocmd('TermClose', {
  group = 'bsuth',
  pattern = TERM_PATTERNS,
  callback = () -> {
    local bufname = get_bufname()
    if !is_blacklist_bufname(bufname) && CWD_CACHE[bufname] != nil {
      CWD_CACHE[bufname] = nil
    }
  },
})
