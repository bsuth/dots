local actions = require('dmenu.actions')
local { nvim_buf_keymap, nvim_feed_termcodes } = require('utils.nvim')
local onedark = require('utils.onedark')

local DMENU_MAX_WINDOW_HEIGHT = 12

local NAMESPACE_ID = vim.api.nvim_create_namespace('')
vim.api.nvim_set_hl(NAMESPACE_ID, 'Ellipses', { fg = onedark.grey })
vim.api.nvim_set_hl(NAMESPACE_ID, 'Focused', { fg = onedark.cyan })

-- -----------------------------------------------------------------------------
-- State
-- -----------------------------------------------------------------------------

local dmenu = {}

dmenu.restore_window = -1
dmenu.window = -1
dmenu.buffer = -1

dmenu.filtered_actions = {}
dmenu.num_filtered_actions = 0

dmenu.has_overflow = false
dmenu.num_visible_actions = 0

dmenu.focused_offset = 0

dmenu.ignore_next_buffer_changes = 0
dmenu.ignore_next_mode_changes = 0

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function update_filter() {
  local filter_text = vim.api.nvim_buf_get_lines(dmenu.buffer, -2, -1, false)[1]

  dmenu.filtered_actions = {}
  dmenu.num_filtered_actions = 0

  local filter_tokens = filter_text:split()

  for _, action in ipairs(actions) {
    local include_action = true

    for _, filter_token in ipairs(filter_tokens) {
      if !action[1]:find(filter_token) {
        include_action = false
        break
      }
    }

    if include_action {
      dmenu.num_filtered_actions += 1
      dmenu.filtered_actions[dmenu.num_filtered_actions] = action
    }
  }

  if 1 + dmenu.num_filtered_actions > DMENU_MAX_WINDOW_HEIGHT {
    dmenu.has_overflow = true
    dmenu.num_visible_actions = DMENU_MAX_WINDOW_HEIGHT - 2
    vim.api.nvim_win_set_height(dmenu.window, DMENU_MAX_WINDOW_HEIGHT)
  } else {
    dmenu.has_overflow = false
    dmenu.num_visible_actions = dmenu.num_filtered_actions
    vim.api.nvim_win_set_height(dmenu.window, 1 + dmenu.num_filtered_actions)
  }
}

local function update_buffer_lines(mode = vim.api.nvim_get_mode().mode) {
  -- Calling `nvim_buf_set_lines` will trigger the `on_lines` listeners for
  -- `dmenu_buffer`, so we need to ignore the next trigger.
  dmenu.ignore_next_buffer_changes += 1

  if mode != 'i' {
    local lines = table.map(dmenu.filtered_actions, [ label ] -> label)
    vim.api.nvim_buf_set_lines(dmenu.buffer, 0, -2, false, lines)
  } else {
    local lines = {}

    if dmenu.has_overflow {
      table.insert(lines, '...')
    }

    for i = dmenu.num_visible_actions - 1, 0, -1 {
      table.insert(lines, dmenu.filtered_actions[dmenu.num_filtered_actions - i][1])
    }

    vim.api.nvim_buf_set_lines(dmenu.buffer, 0, -2, false, lines)

    -- neovim likes to scroll the window when updating the buffer content in
    -- insert mode, so this is required to keep the prompt at the bottom.
    dmenu.ignore_next_mode_changes += 2
    nvim_feed_termcodes('<c-o>zb')
  }

  -- Unset the `modified` status of the buffer after updating it, so we can
  -- close it without throwing a "No write since last change" error.
  vim.api.nvim_buf_set_option(dmenu.buffer, 'modified', false)
}

local function update_highlight() {
  vim.api.nvim_buf_clear_namespace(dmenu.buffer, NAMESPACE_ID, 0, -1)

  if vim.api.nvim_get_mode().mode != 'i' {
    return
  }

  if dmenu.num_filtered_actions > 0 {
    -- -1 for prompt
    -- -1 since `nvim_buf_add_highlight` is 0-index
    local focused_row = vim.api.nvim_buf_line_count(dmenu.buffer) - dmenu.focused_offset - 2
    vim.api.nvim_buf_add_highlight(dmenu.buffer, NAMESPACE_ID, 'Focused', focused_row, 0, -1)
  }

  if dmenu.has_overflow {
    vim.api.nvim_buf_add_highlight(dmenu.buffer, NAMESPACE_ID, 'Ellipses', 0, 0, -1)
  }
}

local function focus_previous_action() {
  dmenu.focused_offset = (dmenu.focused_offset + 1) % dmenu.num_visible_actions
  update_highlight()
}

local function focus_next_action() {
  dmenu.focused_offset = (dmenu.focused_offset - 1) % dmenu.num_visible_actions
  update_highlight()
}

local function start() {
  dmenu.buffer = vim.api.nvim_create_buf(false, false)
  vim.api.nvim_buf_set_option(dmenu.buffer, 'buftype', 'prompt')
  vim.api.nvim_buf_set_option(dmenu.buffer, 'bufhidden', 'wipe')
  vim.api.nvim_buf_set_option(dmenu.buffer, 'swapfile', false)
  vim.fn.prompt_setprompt(dmenu.buffer, '')

  vim.api.nvim_buf_attach(dmenu.buffer, false, {
    -- update only after `textlock` is removed
    on_lines = () -> vim.schedule(() -> {
      if dmenu.ignore_next_buffer_changes > 0 {
        dmenu.ignore_next_buffer_changes -= 1
      } else {
        dmenu.focused_offset = 0
        update_filter()
        update_buffer_lines()
        update_highlight()
      }
    }),
  })

  vim.api.nvim_create_autocmd('ModeChanged', {
    group = 'bsuth',
    buffer = dmenu.buffer,
    callback = () -> {
      if dmenu.ignore_next_mode_changes > 0 {
        dmenu.ignore_next_mode_changes -= 1
      } else {
        dmenu.focused_offset = 0
        update_buffer_lines()
        update_highlight()
      }
    },
  })

  nvim_buf_keymap(dmenu.buffer, 'i', '<c-p>', focus_previous_action)
  nvim_buf_keymap(dmenu.buffer, 'i', '<up>', focus_previous_action)
  nvim_buf_keymap(dmenu.buffer, 'i', '<S-Tab>', focus_previous_action)

  nvim_buf_keymap(dmenu.buffer, 'i', '<c-n>', focus_next_action)
  nvim_buf_keymap(dmenu.buffer, 'i', '<down>', focus_next_action)
  nvim_buf_keymap(dmenu.buffer, 'i', '<Tab>', focus_next_action)

  nvim_buf_keymap(dmenu.buffer, 'i', '<c-q>', () -> {
    vim.api.nvim_set_current_win(dmenu.restore_window)
  })

  nvim_buf_keymap(dmenu.buffer, 'i', '<cr>', () -> {
    vim.api.nvim_set_current_win(dmenu.restore_window)
    if dmenu.num_filtered_actions > 0 {
      local action_index = dmenu.num_filtered_actions - dmenu.focused_offset
      dmenu.filtered_actions[action_index][2]()
    }
  })

  nvim_buf_keymap(dmenu.buffer, 'n', '<cr>', () -> {
    local [ row ] = vim.api.nvim_win_get_cursor(dmenu.window)
    if row > dmenu.num_filtered_actions {
      vim.cmd('startinsert')
    } else {
      vim.api.nvim_set_current_win(dmenu.restore_window)
      dmenu.filtered_actions[row][2]()
    }
  })

  dmenu.restore_window = vim.api.nvim_get_current_win()
  vim.cmd('botright split')
  dmenu.window = vim.api.nvim_get_current_win()
  vim.api.nvim_win_set_buf(dmenu.window, dmenu.buffer)
  vim.api.nvim_win_set_hl_ns(dmenu.window, NAMESPACE_ID) -- Must be called after the buffer is set!

  vim.cmd('startinsert')

  -- Wait until the next tick so that we can properly detect insert mode.
  vim.schedule(() -> {
    update_filter()
    update_buffer_lines()
    update_highlight()
  })
}

local function toggle() {
  if vim.api.nvim_get_current_win() == dmenu.window {
    vim.api.nvim_set_current_win(dmenu.restore_window)
  } else {
    start()
  }
}

-- -----------------------------------------------------------------------------
-- Mappings
-- -----------------------------------------------------------------------------

vim.keymap.set('i', '<m-space>', toggle)
vim.keymap.set('n', '<m-space>', toggle)

-- -----------------------------------------------------------------------------
-- Auto Commands
-- -----------------------------------------------------------------------------

vim.api.nvim_create_autocmd('WinLeave', {
  group = 'bsuth',
  callback = () -> {
    if vim.api.nvim_get_current_win() == dmenu.window {
      vim.api.nvim_win_hide(dmenu.window)
    }
  },
})
