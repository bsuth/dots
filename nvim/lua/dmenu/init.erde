local default_actions = require('dmenu.actions')
local { buffer_keymap } = require('utils.buffer')
local onedark = require('utils.onedark')

-- -----------------------------------------------------------------------------
-- Variables
-- -----------------------------------------------------------------------------

local NAMESPACE_ID = vim.api.nvim_create_namespace('')
vim.api.nvim_set_hl(NAMESPACE_ID, 'Focused', { fg = onedark.cyan })

local INPUT_HEIGHT = 1
local LIST_HEIGHT = 8

local active = false

local actions
local filtered_actions, num_filtered_actions, has_filtered_actions

local focused_list_row, focus_limit

local master_window
local bg_window, bg_buffer
local input_window, input_buffer
local list_window, list_buffer

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function popup(config) {
  local window = vim.api.nvim_open_win(0, true, config)

  vim.cmd('enew')
  local buffer = vim.api.nvim_get_current_buf()

  vim.api.nvim_buf_set_option(buffer, 'bufhidden', 'wipe')
  vim.api.nvim_buf_set_option(buffer, 'swapfile', false)
  vim.api.nvim_buf_set_option(buffer, 'buflisted', false)

  -- Must be called after the buffer is set!
  vim.api.nvim_win_set_hl_ns(window, NAMESPACE_ID)

  return window, buffer
}

local function get_window_configs() {
  local master_width = vim.api.nvim_win_get_width(master_window)
  local master_height = vim.api.nvim_win_get_height(master_window)

  local content_width = math.min(master_width - 2, 32)
  local content_height = INPUT_HEIGHT + 1 + LIST_HEIGHT
  local content_col = math.floor((master_width - content_width) / 2)
  local content_row = math.floor((master_height - content_height) / 2)

  return {
    bg_config = {
      relative = 'win',
      win = master_window,
      style = 'minimal',
      col = 0,
      row = 0,
      width = master_width,
      height = master_height,
      zindex = 1,
    },
    input_config = {
      relative = 'win',
      win = master_window,
      style = 'minimal',
      col = content_col,
      row = content_row,
      width = content_width,
      height = INPUT_HEIGHT,
      zindex = 2,
    },
    list_config = {
      relative = 'win',
      win = master_window,
      style = 'minimal',
      col = content_col,
      row = content_row + INPUT_HEIGHT + 1,
      width = content_width,
      height = LIST_HEIGHT,
      zindex = 2,
    },
  }
}

local function filter() {
  local input_lines = vim.api.nvim_buf_get_lines(input_buffer, 0, 1, false)
  local tokens = input_lines[1]:split()

  filtered_actions = {}
  num_filtered_actions = 0

  for _, action in ipairs(actions) {
    local include_action = true

    for _, token in ipairs(tokens) {
      if !action.label:find(token) {
        include_action = false
        break
      }
    }

    if include_action {
      num_filtered_actions += 1
      filtered_actions[num_filtered_actions] = action
    }
  }

  focused_list_row = 1 -- reset focused row on filter
  has_filtered_actions = num_filtered_actions > 0
  focus_limit = math.min(num_filtered_actions, LIST_HEIGHT)
}

local function render() {
  local lines = {}

  for i = 1, math.min(LIST_HEIGHT, num_filtered_actions) {
    lines[i] = filtered_actions[i].label
  }

  for i = num_filtered_actions + 1, LIST_HEIGHT {
    lines[i] = ''
  }

  vim.api.nvim_buf_set_lines(list_buffer, 0, LIST_HEIGHT, false, lines)

  if has_filtered_actions {
    vim.api.nvim_buf_add_highlight(list_buffer, NAMESPACE_ID, 'Focused', focused_list_row - 1, 0, -1)
  }
}

local function refresh() {
  filter()
  render()
}

local function stop() {
  active = false -- set this first so we can check it in autocommands

  if vim.api.nvim_win_is_valid(bg_window) {
    vim.api.nvim_win_hide(bg_window)
  }

  if vim.api.nvim_win_is_valid(input_window) {
    vim.api.nvim_win_hide(input_window)
  }

  if vim.api.nvim_win_is_valid(list_window) {
    vim.api.nvim_win_hide(list_window)
  }

  if vim.api.nvim_win_is_valid(master_window) {
    vim.api.nvim_set_current_win(master_window)
  }
}

local function focus_prev() {
  focused_list_row = focused_list_row == 1 && focus_limit || (focused_list_row - 1)
  render()
}

local function focus_next() {
  focused_list_row = focused_list_row == focus_limit && 1 || (focused_list_row + 1)
  render()
}

local function submit() {
  local focused_action = filtered_actions[focused_list_row]

  if focused_action == nil {
    return
  }

  stop()
  focused_action.callback()
}

local function start(new_actions) {
  if active {
    stop()
  }

  master_window = vim.api.nvim_get_current_win()
  actions = new_actions || default_actions

  local { bg_config, input_config, list_config } = get_window_configs()
  bg_window, bg_buffer = popup(bg_config)
  input_window, input_buffer = popup(input_config)
  list_window, list_buffer = popup(list_config)

  vim.api.nvim_buf_set_option(input_buffer, 'buftype', 'prompt')
  vim.fn.prompt_setprompt(input_buffer, '')

  vim.api.nvim_buf_attach(input_buffer, false, {
    -- Schedule to run after `textlock` is removed
    on_lines = () -> vim.schedule(refresh),
  })

  buffer_keymap(input_buffer, 'i', '<c-c>', stop)
  buffer_keymap(input_buffer, 'n', '<c-c>', stop)
  buffer_keymap(input_buffer, 'i', '<c-q>', stop)
  buffer_keymap(input_buffer, 'n', '<c-q>', stop)
  buffer_keymap(input_buffer, 'n', '<esc>', stop)

  buffer_keymap(input_buffer, 'i', '<c-p>', focus_prev)
  buffer_keymap(input_buffer, 'i', '<up>', focus_prev)
  buffer_keymap(input_buffer, 'i', '<S-Tab>', focus_prev)
  buffer_keymap(input_buffer, 'n', '<c-p>', focus_prev)
  buffer_keymap(input_buffer, 'n', '<up>', focus_prev)
  buffer_keymap(input_buffer, 'n', '<S-Tab>', focus_prev)

  buffer_keymap(input_buffer, 'i', '<c-n>', focus_next)
  buffer_keymap(input_buffer, 'i', '<down>', focus_next)
  buffer_keymap(input_buffer, 'i', '<Tab>', focus_next)
  buffer_keymap(input_buffer, 'n', '<c-n>', focus_next)
  buffer_keymap(input_buffer, 'n', '<down>', focus_next)
  buffer_keymap(input_buffer, 'n', '<Tab>', focus_next)

  buffer_keymap(input_buffer, 'i', '<cr>', submit)
  buffer_keymap(input_buffer, 'n', '<cr>', submit)

  refresh()

  vim.api.nvim_set_current_win(input_window)
  vim.cmd('echo') -- clear command line
  vim.cmd('startinsert')
  active = true
}

local function toggle() {
  if active {
    stop()
  } else {
    start()
  }
}

-- -----------------------------------------------------------------------------
-- Mappings
-- -----------------------------------------------------------------------------

vim.keymap.set('i', '<m-space>', toggle)
vim.keymap.set('n', '<m-space>', toggle)

-- -----------------------------------------------------------------------------
-- Auto Commands
-- -----------------------------------------------------------------------------

vim.api.nvim_create_autocmd('WinLeave', {
  group = 'bsuth',
  callback = () -> active && toggle(),
})

vim.api.nvim_create_autocmd('VimResized', {
  group = 'bsuth',
  callback = () -> {
    if active {
      local { bg_config, input_config, list_config } = get_window_configs()
      vim.api.nvim_win_set_config(bg_window, bg_config)
      vim.api.nvim_win_set_config(input_window, input_config)
      vim.api.nvim_win_set_config(list_window, list_config)
    }
  }
})
